# 最新 react-redux8 源码超详细解析：用了两天时间再读 react-redux 源码

react-redux 这个库想必熟悉 react 的人都不陌生，用一句话描述它就是：它作为『redux 这个框架无关的数据流管理库』和『react 这个视图库』的桥梁，使得 react 中能使用 redux 中的 dispatch 更新 store，并能监听 store 的变化并通知 react 的相关组件更新，从而能让 react 将状态放在外部管理（有利于 model 集中管理，能利用 redux 单项数据流架构，数据流易预测易维护，也极大的方便了任意层级组件间通信等等好处）。

## 正文前的吹水阶段 1：既然是『再读』，那『首读』呢？

不知道大家平时在逛技术论坛（如逼乎）的时候，有没有看见过类似这样的评论：redux 性能不好，mobx 更香……

喜欢刨根问底的人（比如我）看到了不禁想问更多问题：

1. 究竟是 redux 性能不好还是 react-redux 性能不好？
2. 具体不好在哪里？
3. 能不能避免？

这些问题你问他了，他可能也不知道怎么解释，就算回复了，可能也是三言两语，不够深入。与此同时还有一个更基本的问题， react-redux 是如何关联起 redux 和 react 的？这个问题搜一搜倒是有不少源码解析，我曾经看过一篇很详细的，不过很可惜是老版本的，还在用 class component，所以当时的我决定自己去看源码。当时属于是粗读，简单总结就是 Provider 中有 Subscription 实例，connect 这个高阶组件中也有 Subscription 实例，并且有负责自身更新的 hooks: useReducer，useReducer 的 dispatch 会被注册进 Subscription 的 listeners，listeners 中有一个方法 notify 会遍历调用每个 listener，notify 会被注册给 redux 的 subscribe，从而 redux 的 state 更新后会通知给所有 connect 组件，当然每个 connect 都有检查自己是否需要更新的方法 checkForUpdates 来避免不必要的更新，具体细节就不说了。

总之，当时我只看了大概逻辑，但是可以解答我上面的问题了：

1. react-redux 确实有可能性能不好。而至于 redux，每次 dispatch 都会让 state 去每个 reducer 走一遍，并且为了保证数据 immutable 也会有额外的复制开销，所以性能也不会比 mutable 好。不过为了一个清晰可靠的数据流架构，这点开销在大部分场景也算值得。

2. react-redux 性能具体不好在哪里？因为每个 connect 不管需不需要更新都会被通知一次，开发者定义的 selector 都会被调用一遍甚至多遍，如果 selector 逻辑复杂，还是会比较消耗性能的。

3. 那么 react-redux 一定会性能不好吗？不一定，根据上面的分析，如果你的 selector 逻辑简单（或者将复杂派生计算都放在 redux 的 reducer 里，但是这样可能不利于构建一个合理的领域 model），connect 用的不多，那么性能并不会被 mobx 这样的细粒度更新拉开太多。也就是说 selector 里业务计算不复杂、使用全局状态管理的组件不多的情况下，完全不会有可感知的性能问题。那如果 selector 里面的业务计算复杂怎么办呢？能不能完全避免呢？当然可以，你可以用 reselect 这个库，它会缓存 selector 的结果，只有原始数据变化时才会重新计算派生数据。

这就是我的『首读』，我带着目的和问题去读源码，现在问题已经解决了，按理说没有『再读』这件事了，那么它是因何而起的呢？

## 正文前的吹水阶段 2：为什么要『再读』？

前段时间我关注了一个 github 上的前端精读周刊，他上周发了一篇文章：[精读《zustand 源码》](https://github.com/ascoders/weekly/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/227.%20%E7%B2%BE%E8%AF%BB%E3%80%8Azustand%20%E6%BA%90%E7%A0%81%E3%80%8B.md)，这篇文章我没第一时间看，我先去了 zustand 的 github 看了一下。

zustand 是一个非常时髦的基于 hooks 的状态管理库，基于简化的 flux 架构，也是 2021 年 Star 增长最快的 React 状态管理库。可以说是 redux + react-redux 的竞争者。

它的开头是这样介绍的

![image](https://user-images.githubusercontent.com/42726028/151149221-199b5e92-5521-4be1-976b-b8cc439b3da7.png)

> 大意是：它是一个小巧、快速、可扩展的、使用简化的 flux 架构的状态管理解决方案。有基于 hooks 的 api，使用起来十分舒适、人性化。
> 不要因为它很可爱而忽视它（感觉作者把它类比成小熊了，封面图也是一个可爱的小熊）。它有很多的爪子，花了大量的时间去处理常见的陷阱，比如可怕的子代僵尸问题(zombie child problem)，react 并发模式(react concurrency)，以及使用 portals 时多个 render 之间的 context 丢失(context loss)。它可能是 React 领域中唯一一个能够正确处理所有这些问题的状态管理器。

当我点进 [zombie child problem](https://react-redux.js.org/api/hooks#stale-props-and-zombie-children) 时，是 react-redux 官方文档，我顿时来了兴趣，想看看这个问题是什么以及 react-redux 怎么会有这个问题它又是如何解决的。想看原文可以直接点链接，我这里把它翻译一下。


