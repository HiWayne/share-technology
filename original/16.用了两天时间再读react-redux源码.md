# 数万字长文！最新 react-redux8 源码超详细解析：用了两天时间再读 react-redux 源码

react-redux 这个库想必熟悉 react 的人都不陌生，用一句话描述它就是：它作为『redux 这个框架无关的数据流管理库』和『react 这个视图库』的桥梁，使得 react 中能更新 redux 的 store，并能监听 store 的变化并通知 react 的相关组件更新，从而能让 react 将状态放在外部管理（有利于 model 集中管理，能利用 redux 单项数据流架构，数据流易预测易维护，也极大的方便了任意层级组件间通信等等好处）。

下面有些部分和源码解析没有直接关系，但读了也能有所技术收获。想直接看解析部分的可以跳转到[React-Redux 源码解析部分](#react-redux-源码解析)

## 正文前的吹水阶段 1：既然是『再读』，那『首读』呢？

不知道大家平时在逛技术论坛（如逼乎）的时候，有没有看见过类似这样的评论：redux 性能不好，mobx 更香……

喜欢刨根问底的人（比如我）看到了不禁想问更多问题：

1. 究竟是 redux 性能不好还是 react-redux 性能不好？
2. 具体不好在哪里？
3. 能不能避免？

这些问题你问他了，他可能也不知道怎么解释，就算回复了，可能也是三言两语，不够深入。与此同时还有一个更基本的问题， react-redux 是如何关联起 redux 和 react 的？这个问题搜一搜倒是有不少源码解析，我曾经看过一篇很详细的，不过很可惜是老版本的，还在用 class component，所以当时的我决定自己去看源码。当时属于是粗读，简单总结就是 Provider 中有 Subscription 实例，connect 这个高阶组件中也有 Subscription 实例，并且有负责自身更新的 hooks: useReducer，useReducer 的 dispatch 会被注册进 Subscription 的 listeners，listeners 中有一个方法 notify 会遍历调用每个 listener，notify 会被注册给 redux 的 subscribe，从而 redux 的 state 更新后会通知给所有 connect 组件，当然每个 connect 都有检查自己是否需要更新的方法 checkForUpdates 来避免不必要的更新，具体细节就不说了。

总之，当时我只粗读了整体逻辑，但是可以解答我上面的问题了：

1. react-redux 确实有可能性能不好。而至于 redux，每次 dispatch 都会让 state 去每个 reducer 走一遍，并且为了保证数据 immutable 也会有额外的复制开销，所以性能也不会比 mutable 好。不过为了一个清晰可靠的数据流架构，这点开销在大部分场景也算值得。

2. react-redux 性能具体不好在哪里？因为每个 connect 不管需不需要更新都会被通知一次，开发者定义的 selector 都会被调用一遍甚至多遍，如果 selector 逻辑复杂，还是会比较消耗性能的。

3. 那么 react-redux 一定会性能不好吗？不一定，根据上面的分析，如果你的 selector 逻辑简单（或者将复杂派生计算都放在 redux 的 reducer 里，但是这样可能不利于构建一个合理的领域 model），connect 用的不多，那么性能并不会被 mobx 这样的细粒度更新拉开太多。也就是说 selector 里业务计算不复杂、使用全局状态管理的组件不多的情况下，完全不会有可感知的性能问题。那如果 selector 里面的业务计算复杂怎么办呢？能不能完全避免呢？当然可以，你可以用 reselect 这个库，它会缓存 selector 的结果，只有原始数据变化时才会重新计算派生数据。

这就是我的『首读』，我带着目的和问题去读源码，现在问题已经解决了，按理说没有『再读』这件事了，那么它是因何而起的呢？

## 正文前的吹水阶段 2：为什么要『再读』？

前段时间我关注了一个 github 上的前端精读周刊，他上周发了一篇文章：[精读《zustand 源码》](https://github.com/ascoders/weekly/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/227.%20%E7%B2%BE%E8%AF%BB%E3%80%8Azustand%20%E6%BA%90%E7%A0%81%E3%80%8B.md)，这篇文章我没第一时间看，我先去了 zustand 的 github 看了一下。

zustand 是一个非常时髦的基于 hooks 的状态管理库，基于简化的 flux 架构，也是 2021 年 Star 增长最快的 React 状态管理库。可以说是 redux + react-redux 的竞争者。

它的开头是这样介绍的

![image](https://user-images.githubusercontent.com/42726028/151149221-199b5e92-5521-4be1-976b-b8cc439b3da7.png)

> 大意是：它是一个小巧、快速、可扩展的、使用简化的 flux 架构的状态管理解决方案。有基于 hooks 的 api，使用起来十分舒适、人性化。
> 不要因为它很可爱而忽视它（感觉作者把它类比成小熊了，封面图也是一个可爱的小熊）。它有很多的爪子，花了大量的时间去处理常见的陷阱，比如可怕的子代僵尸问题(zombie child problem)，react 并发模式(react concurrency)，以及使用 portals 时多个 render 之间的 context 丢失(context loss)。它可能是 React 领域中唯一一个能够正确处理所有这些问题的状态管理器。

里面讲到一个东西：zombie child problem。当我点进 [zombie child problem](https://react-redux.js.org/api/hooks#stale-props-and-zombie-children) 时，是 react-redux 的官方文档，让我们一起来看看这个问题是什么以及 react-redux 是如何解决的。想看原文可以直接点链接。

> **"Stale Props" and "Zombie Children"（过期 Props 和僵尸子节点问题）**
>
> 自 v7.1.0 版本发布以后，react-redux 就可以使用 hooks api 了，官方也推荐使用 hooks 作为组件中的默认使用方法。但是有一些边缘情况可能会发生，这篇文档就是让我们意识到这些事的。
>
> react-redux 实现中最难的地方之一就是：如果你的 mapStateToProps 是(state, ownProps)这样使用的，它将会每次被传入『最新的』props。一直到版本 4 都一直有边缘场景下的重复的 bug 被报告，比如：有一个列表 item 的数据被删除了，mapStateToProps 里面就报错了。
>
> 从版本 5 开始，react-redux 试图保证 `ownProps` 的一致性。在版本 7 里面，每个 `connect()`内部都有一个自定义的 Subscription 类，从而当 connect 里面又有 connect，它能形成一个嵌套的结构。这确保了树中更低层的 connect 组件只会在离它最近的祖先 connect 组件更新后才会接受到来自 store 的更新。然而，这个实现依赖于每个 `connect()`实例里面覆写了内部 React Context 的一部分（subscription 那部分），用它自身的 Subscription 实例用于嵌套。然后用这个新的 React Context ( \<ReactReduxContext.Provider\> ) 渲染子节点。
>
> 如果用 hooks，没有办法渲染一个 context.Provider，这就代表它不能让 subscriptions 有嵌套的结构。因为这一点，"stale props" 和 "zombie child" 问题可能在『用 hooks 代替 connect』 的应用里重新发生。
>
> 具体来说，"stale props" 会出现在这种场景：
>
> - selector 函数会根据这个组件的 props 计算出数据
> - 父组件会重新 render，并传给这个组件新的 props
> - 但是这个组件会在 props 更新之前就执行 selector（译者注：因为子组件的来自 store 的更新是在 useLayoutEffect/useEffect 中注册的，所以子组件先于父组件注册，redux 触发订阅会先触发子组件的更新方法）
>
> 这种旧的 props 和最新 store state 算出来的结果，很有可能是错误的，甚至会引起报错。
>
> "Zombie child"具体是指在以下场景：
>
> - 多个嵌套的 connect 组件 mounted，子组件比父组件更早的注册到 store 上
> - 一个 action dispatch 了在 store 里删除数据的行为，比如一个 todo list 中的 item
> - 父组件在渲染的时候就会少一个 item 子组件
> - 但是，因为子组件是先被订阅的，它的 subscription 先于父组件。当它计算一个基于 store 和 props 计算的值时，部分数据可能已经不存在了，如果计算逻辑不注意的话就会报错。
>
> `useSelector()`试图这样解决这个问题：它会捕获所有来自 store 更新导致的 selector 计算中的报错，当错误发生时，组件会强制更新，这时 selector 会再次执行。这个需要 selector 是个纯函数并且你没有逻辑依赖 selector 抛出错误。
>
> 如果你更喜欢自己处理，这里有一个可能有用的事项能帮助你在使用 `useSelector()` 时避免这些问题
>
> - 不要在 selector 的计算中依赖 props
> - 如果在：你必须要依赖 props 计算并且 props 将来可能发生变化、依赖的 store 数据可能会被删除，这两种情况下时，你要防备性的写 selector。不要直接像 `state.todos[props.id].name` 这样读取值，而是先读取 `state.todos[props.id]`，验证它是否存在再读取 `todo.name`
>   因为 `connect` 向 context provider 增加了必要的 `Subscription`，它会延迟执行子 subscriptions 直到这个 connected 组件 re-rendered。组件树中如果有 connected 组件在使用 `useSelector` 的组件的上层，也可以避免这个问题，因为父 connect 有和 hooks 组件同样的 store 更新（译者注：父 connect 组件更新后才会更新子 hooks 组件，同时 connect 组件的更新会带动子节点更新，被删除的节点在此次父组件的更新中已经卸载了：因为上文中说 `state.todos[props.id].name` ，说明 hooks 组件是上层通过 ids 遍历出来的。于是后续来自 store 的子 hooks 组件更新不会有被删除的）

以上的解释可能让大家明白了 "Stale Props" 和 "Zombie Children" 问题是如何产生的以及 react-redux 大概是怎么解决的，而且似乎并不能完全解决，而且具体解决的细节也没有说到。这部分的疑惑和缺失就是我准备再读 react-redux 源码的原因。

## React-Redux 源码解析

React-Redux 版本来自截止 2022.01.27 时的最新版本 v8.0.0-beta.2（有点悲催的是，前几天读源码的时候还是 7 版本，没想到刚读完就升到 8 了，不过主要是从 js 升级到 ts 以及一些小改动）

在讲具体细节之前我想先说一下总体的抽象设计，让大家心中带着设计蓝图去读其中的细节，否则只看细节很难让它们之间串联起来明白它们是如何共同协作完成整个功能的。

React-Redux 的 Provider 和 connect 都提供了自己的贯穿子树的 context，它们的所有的子节点都可以拿到它们，并会将自己的更新方法交给它们。最终形成了**根 <-- 父 <-- 子**这样的收集顺序。根收集的更新方法会由 redux 触发，父收集的更新方法在父更新后再更新，于是保证了父节点被 redux 更新后子节点才更新的顺序。

![react-redux过程抽象图](https://user-images.githubusercontent.com/42726028/151991192-d7ba1abf-c849-42b1-8d7f-da991d40c70d.jpeg)

简单的宏观设计就如上所示，初次看不能理解的很深入，不过没关系，看完下面的细节分析后再回过头看看这里会有新的收获。

### 首先从项目构建入口看起

![image](https://user-images.githubusercontent.com/42726028/151580982-94bb6e23-aa03-4c41-8197-89a42a49ef73.png)

可以看出它的 umd 包是通过 rollup 构建的（`build:umd`、`build:umd:min`），esm 和 commonjs 包是通过 babel 编译输出的（`build:commonjs`、`build:es`）。我们只看`build:es`：`"babel src --extensions \".js,.ts,.tsx\" --out-dir es"`。意思是使用 babel 转换 src 目录下的`.js,.ts,.tsx`文件并输出到 es 目录（这一点和业务项目有些区别，因为是 npm 包所以并不需要打包为一个文件，否则不同 npm 库之间可能会有重复依赖，每个文件依然保持 import 引入只是内容编译就可以了，最终在开发者的项目里会把它们构建到一起的）。

下面看一下.babelrc.js 做了什么

![image](https://user-images.githubusercontent.com/42726028/151946191-2fa1bd0c-1b6e-4fed-8183-217d7f1ced53.png)

可以看到 bable 的 presets 中的`@babel/preset-typescript`负责将 ts 编译为 js，`@babel/preset-env`负责将 ECMA 新语法编译为 es5（只能编译 syntax，api 需要额外插件）。关于 babel 的 plugins，`@babel/transform-modules-commonjs`解决了 babel 重复 helper 的问题，可以按需引入统一的 corejs 库中的 polyfill，这里是通过 `useESModules` 的配置来决定 esm 还是 commonjs 的 helper，但[官方文档](https://babeljs.io/docs/en/babel-plugin-transform-runtime#useesmodules)中在 7.13.0 开始已经废弃这个配置了，可以直接通过`package.json`的`exports`来判断。其他的 plugin 也都是和语法编译相关的，比如私有方法、私有属性、静态属性、jsx、装饰器等语法的编译，以及`@babel/plugin-transform-modules-commonjs`这个将 esm 引入语法编译为 commonjs 的库，由环境变量 NODE_ENV 决定是否使用。

![image](https://user-images.githubusercontent.com/42726028/151973195-33689fb8-f356-45c8-99cd-bcd1403cf4c3.png)

根据 package.json 的 module 字段（[关于 main、module、browser 字段的优先级](https://github.com/SunshowerC/blog/issues/8)），最终入口是根目录下的 es/index.js，由于它是由 babel 根据源目录输出的，所以源代码入口就是`src/index.ts`。

![image](https://user-images.githubusercontent.com/42726028/151975000-bb4ad66e-facf-4be0-a2ce-a4ffef03b81a.png)

### 从常用的 api 源码切入

从上图可以看出，入口文件的输出只有`batch`和`exports`文件的全部 export，所以我们去看 `exports.ts`

![image](https://user-images.githubusercontent.com/42726028/151975781-995c5c6e-f626-4b3b-ab85-a29537164eb3.png)

`Provider`、`connect`、`useSelector`、`useDispatch`占据了我们平时使用的大部分场景，所以我们从这四个 api 切入。

#### Provider

![image](https://user-images.githubusercontent.com/42726028/151976522-556eec40-dfdf-4182-b465-d13bd223cc06.png)

`Provider`来自`src/components/Provider.tsx`。

它是一个 React 组件，本事并没有任何视图内容，最终展示的是 children，只不过给 children 外面加了一层 Context Provider，这也是这个 api 为什么叫 Provider 的原因。那具体这个组件想往下面透传什么呢。

```ts
const contextValue = useMemo(() => {
  const subscription = createSubscription(store);
  return {
    store,
    subscription,
    getServerState: serverState ? () => serverState : undefined,
  };
}, [store, serverState]);
```

可以看到透传的是一个由`store`、`subscription`、`getServerState`组成的对象。下面分别讲一下对象的 3 个属性作用。

`store`是 redux 的 store，通过 store prop 传给 Provider 组件的。

`subscription` 是由 createSubscription 这个对象工厂创建，它生成了 subscription 对象，它是后续嵌套收集订阅的**关键**。关于 createSubscription 的代码细节后面再说。

`getServerState`是 8.0.0 版本新加的，它用于在 SSR 中，当初始『注水』`hydrate` 时获取服务器端状态快照的，以便保证两端状态一致性。它的控制权完全在开发者，只要把状态快照通过 serverState 这个 prop 给这个组件即可。不了解 SSR、hydrate 相关概念的可以去读一下 Dan Abramov 的一篇[discussions](https://github.com/reactwg/react-18/discussions/37)，虽然它的主题不是专门讲 SSR 的，但是开头介绍了相关概念，而且 Dan 的文章一向形象而通俗易懂。

Provider 组件紧接着做的事情是：

```ts
const previousState = useMemo(() => store.getState(), [store]);

useIsomorphicLayoutEffect(() => {
  const { subscription } = contextValue;
  subscription.onStateChange = subscription.notifyNestedSubs;
  subscription.trySubscribe();

  if (previousState !== store.getState()) {
    subscription.notifyNestedSubs();
  }
  return () => {
    subscription.tryUnsubscribe();
    subscription.onStateChange = undefined;
  };
}, [contextValue, previousState]);

const Context = context || ReactReduxContext;

return <Context.Provider value={contextValue}>{children}</Context.Provider>;
```

获取了一次最新 state 并命名为 `previousState`，只要 store 单例不发生变化，它是不会更新的。一般项目中也不太会改变 redux 单例。

`useIsomorphicLayoutEffect` 只是一个 facade，从 isomorphic 的命名也可以看出它是和同构相关的。在 server 环境是 useEffect，在浏览器环境是 useLayoutEffect

它的代码很简单

```ts
import { useEffect, useLayoutEffect } from "react";

// React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
// subscription callback always has the selector from the latest render commit
// available, otherwise a store update may happen between render and the effect,
// which may cause missed updates; we also must ensure the store subscription
// is created synchronously, otherwise a store update may occur before the
// subscription is created and an inconsistent state may be observed

// Matches logic in React's `shared/ExecutionEnvironment` file
export const canUseDOM = !!(
  typeof window !== "undefined" &&
  typeof window.document !== "undefined" &&
  typeof window.document.createElement !== "undefined"
);

export const useIsomorphicLayoutEffect = canUseDOM
  ? useLayoutEffect
  : useEffect;
```

但是这样做的原因并不简单：首先，在服务端使用 useLayoutEffect 会抛出警告，为了绕过它于是在服务端转而使用 useEffect。其次，为什么一定要在 useLayoutEffect/useEffect 里面做？因为一个 store 更新可能发生在 render 阶段和副作用阶段之间，如果在 render 时就做，可能会错过更新，必须要确保 store subscription 的回调拥有来自最新更新的 selector。同时还要确保 store subscription 的创建必须是同步的，否则一个 store 更新可能发生在订阅之前（如果订阅是异步的话），这时订阅还没有被创建，从而有了不一致的状态。

如果原因看了不是很明白，结合下面的例子就明白了。

Provider 在 `useIsomorphicLayoutEffect` 里做了这样的事：

```ts
subscription.trySubscribe();

if (previousState !== store.getState()) {
  subscription.notifyNestedSubs();
}
```

首先收集 subscription 的订阅，然后看最新的状态和之前在 render 的状态是否一致，如果不一致则通知更新。如果这一段不放在 useLayoutEffect/useEffect 里，而是放在 render 里，那么现在仅仅订阅了它自己，它的子组件并没有订阅，如果子组件在渲染过程中更新了 redux store，那么子组件们就错过了更新通知。同时 react 的 useLayoutEffect/useEffect 是自下而上调用的，子组件的先调用，父组件的后调用。这里由于是 react-redux 的根节点了，它的 useLayoutEffect/useEffect 会在最后被调用，这时能确保子组件该注册订阅的都注册了，同时也能确保子组件渲染过程中可能发生的更新都已经发生了。所以再最后读取一次 state，比较一下是否要通知它们更新。这就是为什么要选择 useLayoutEffect/useEffect。

接下来我们完整的看一下 Provider 在 `useIsomorphicLayoutEffect` 中做的事情

```ts
useIsomorphicLayoutEffect(() => {
  const { subscription } = contextValue;
  subscription.onStateChange = subscription.notifyNestedSubs;
  subscription.trySubscribe();

  if (previousState !== store.getState()) {
    subscription.notifyNestedSubs();
  }
  return () => {
    subscription.tryUnsubscribe();
    subscription.onStateChange = undefined;
  };
}, [contextValue, previousState]);
```

首先是设置 subscription 的 onStateChange（是个空方法，需要注入实现），它会在更新触发时调用，它这里希望将来调用的是`subscription.notifyNestedSubs`，`subscription.notifyNestedSubs`会触发这个 subscription 收集的所有子订阅。也就是说这里的更新回调和『更新』没有直接关系，而是触发子节点们的更新方法。

然后调用了`subscription.trySubscribe()`，它会将自己的 onStateChange 交给父级 subscription 或者 redux 订阅

最后它会判断之前的 state 和最新的是否一致，如果不一致会调用`subscription.notifyNestedSubs()`，它会触发这个 subscription 收集的所有子订阅从而更新。

返回了注销相关的函数，注销在父级的订阅，将`subscription.onStateChange`重新置为空方法。它们会在组件卸载或 re-render （仅 store 变化时）时被调用。

这里有很多地方都涉及到了 subscription，subscription 的那些方法只是讲了大概功能，关于 subscription 的细节会在后面 subscription 的部分讲到。

完整的`Provider`源码和注释如下：

```ts
function Provider<A extends Action = AnyAction>({
  store,
  context,
  children,
  serverState,
}: ProviderProps<A>) {
  // 生成了一个用于context透传的对象，包含redux store、subscription实例、SSR时可能用到的函数
  const contextValue = useMemo(() => {
    const subscription = createSubscription(store);
    return {
      store,
      subscription,
      getServerState: serverState ? () => serverState : undefined,
    };
  }, [store, serverState]);

  // 获取一次当前的redux state，因为后续子节点的渲染可能会修改state，所以它叫previousState
  const previousState = useMemo(() => store.getState(), [store]);

  // 在useLayoutEffect或useEffect中
  useIsomorphicLayoutEffect(() => {
    const { subscription } = contextValue;
    // 设置subscription的onStateChange方法
    subscription.onStateChange = subscription.notifyNestedSubs;
    // 将subscription的更新回调订阅给父级，这里会订阅给redux
    subscription.trySubscribe();

    // 判断state经过渲染后是否变化，如果变化则触发所有子订阅更新
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    // 组件卸载时的注销操作
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = undefined;
    };
  }, [contextValue, previousState]);

  const Context = context || ReactReduxContext;

  // 最终Provider组件只是为了将contextValue透传下去，组件UI完全使用children
  return <Context.Provider value={contextValue}>{children}</Context.Provider>;
}
```

总结一下 Provider 其实很简单，Provider 组件只是为了将 contextValue 透传下去，让子组件能够拿到 redux store、subscription 实例、服务器端状态函数。

#### Subscription

这里会讲到 Provider 中出镜率很高的 subscription 部分，它是 react-redux 能够嵌套收集订阅的关键。其实这里把它叫做 `Subscription` 已经不太合适了，在 8.0.0 版本之前，react-redux 确实是通过 Subscription class 实现它的，你可以通过`new Subscription()`使用创建 subscription 实例。但在 8.0.0 之后，已经变成了`createSubscription`函数创建 subscription 对象，内部用闭包替代原先的属性。用函数替代 class 有一个好处是，不需要关心 this 的指向，函数内部方法修改的永远是内部的闭包，不会出现 class 方法被赋值给其他变量后出现 this 指向变化的问题，降低了开发时的心智负担。闭包也更加私有化，增加了变量安全。同时在一个支持 hooks 的库里，用函数实现也更符合开发范式。
