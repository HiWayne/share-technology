# 数万字长文！最新 react-redux8 源码超详细解析：用了两天时间再读 react-redux 源码

react-redux 这个库想必熟悉 react 的人都不陌生，用一句话描述它就是：它作为『redux 这个框架无关的数据流管理库』和『react 这个视图库』的桥梁，使得 react 中能更新 redux 的 store，并能监听 store 的变化并通知 react 的相关组件更新，从而能让 react 将状态放在外部管理（有利于 model 集中管理，能利用 redux 单项数据流架构，数据流易预测易维护，也极大的方便了任意层级组件间通信等等好处）。

下面有些部分和源码解析没有直接关系，但读了也能有所技术收获。想直接看解析部分的可以跳转到[React-Redux 源码解析部分](#react-redux-源码解析)

## 正文前的吹水阶段 1：既然是『再读』，那『首读』呢？

不知道大家平时在逛技术论坛（如逼乎）的时候，有没有看见过类似这样的评论：redux 性能不好，mobx 更香……

喜欢刨根问底的人（比如我）看到了不禁想问更多问题：

1. 究竟是 redux 性能不好还是 react-redux 性能不好？
2. 具体不好在哪里？
3. 能不能避免？

这些问题你问他了，他可能也不知道怎么解释，就算回复了，可能也是三言两语，不够深入。与此同时还有一个更基本的问题， react-redux 是如何关联起 redux 和 react 的？这个问题搜一搜倒是有不少源码解析，我曾经看过一篇很详细的，不过很可惜是老版本的，还在用 class component，所以当时的我决定自己去看源码。当时属于是粗读，简单总结就是 Provider 中有 Subscription 实例，connect 这个高阶组件中也有 Subscription 实例，并且有负责自身更新的 hooks: useReducer，useReducer 的 dispatch 会被注册进 Subscription 的 listeners，listeners 中有一个方法 notify 会遍历调用每个 listener，notify 会被注册给 redux 的 subscribe，从而 redux 的 state 更新后会通知给所有 connect 组件，当然每个 connect 都有检查自己是否需要更新的方法 checkForUpdates 来避免不必要的更新，具体细节就不说了。

总之，当时我只粗读了整体逻辑，但是可以解答我上面的问题了：

1. react-redux 确实有可能性能不好。而至于 redux，每次 dispatch 都会让 state 去每个 reducer 走一遍，并且为了保证数据 immutable 也会有额外的复制开销，所以性能也不会比 mutable 好。不过为了一个清晰可靠的数据流架构，这点开销在大部分场景也算值得。

2. react-redux 性能具体不好在哪里？因为每个 connect 不管需不需要更新都会被通知一次，开发者定义的 selector 都会被调用一遍甚至多遍，如果 selector 逻辑复杂，还是会比较消耗性能的。

3. 那么 react-redux 一定会性能不好吗？不一定，根据上面的分析，如果你的 selector 逻辑简单（或者将复杂派生计算都放在 redux 的 reducer 里，但是这样可能不利于构建一个合理的领域 model），connect 用的不多，那么性能并不会被 mobx 这样的细粒度更新拉开太多。也就是说 selector 里业务计算不复杂、使用全局状态管理的组件不多的情况下，完全不会有可感知的性能问题。那如果 selector 里面的业务计算复杂怎么办呢？能不能完全避免呢？当然可以，你可以用 reselect 这个库，它会缓存 selector 的结果，只有原始数据变化时才会重新计算派生数据。

这就是我的『首读』，我带着目的和问题去读源码，现在问题已经解决了，按理说没有『再读』这件事了，那么它是因何而起的呢？

## 正文前的吹水阶段 2：为什么要『再读』？

前段时间我关注了一个 github 上的前端精读周刊，他上周发了一篇文章：[精读《zustand 源码》](https://github.com/ascoders/weekly/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/227.%20%E7%B2%BE%E8%AF%BB%E3%80%8Azustand%20%E6%BA%90%E7%A0%81%E3%80%8B.md)，这篇文章我没第一时间看，我先去了 zustand 的 github 看了一下。

zustand 是一个非常时髦的基于 hooks 的状态管理库，基于简化的 flux 架构，也是 2021 年 Star 增长最快的 React 状态管理库。可以说是 redux + react-redux 的竞争者。

它的开头是这样介绍的

![image](https://user-images.githubusercontent.com/42726028/151149221-199b5e92-5521-4be1-976b-b8cc439b3da7.png)

> 大意是：它是一个小巧、快速、可扩展的、使用简化的 flux 架构的状态管理解决方案。有基于 hooks 的 api，使用起来十分舒适、人性化。
> 不要因为它很可爱而忽视它（感觉作者把它类比成小熊了，封面图也是一个可爱的小熊）。它有很多的爪子，花了大量的时间去处理常见的陷阱，比如可怕的子代僵尸问题(zombie child problem)，react 并发模式(react concurrency)，以及使用 portals 时多个 render 之间的 context 丢失(context loss)。它可能是 React 领域中唯一一个能够正确处理所有这些问题的状态管理器。

里面讲到一个东西：zombie child problem。当我点进 [zombie child problem](https://react-redux.js.org/api/hooks#stale-props-and-zombie-children) 时，是 react-redux 的官方文档，让我们一起来看看这个问题是什么以及 react-redux 是如何解决的。想看原文可以直接点链接。

> **"Stale Props" and "Zombie Children"（过期 Props 和僵尸子节点问题）**
>
> 自 v7.1.0 版本发布以后，react-redux 就可以使用 hooks api 了，官方也推荐使用 hooks 作为组件中的默认使用方法。但是有一些边缘情况可能会发生，这篇文档就是让我们意识到这些事的。
>
> react-redux 实现中最难的地方之一就是：如果你的 mapStateToProps 是(state, ownProps)这样使用的，它将会每次被传入『最新的』props。一直到版本 4 都一直有边缘场景下的重复的 bug 被报告，比如：有一个列表 item 的数据被删除了，mapStateToProps 里面就报错了。
>
> 从版本 5 开始，react-redux 试图保证 `ownProps` 的一致性。在版本 7 里面，每个 `connect()`内部都有一个自定义的 Subscription 类，从而当 connect 里面又有 connect，它能形成一个嵌套的结构。这确保了树中更低层的 connect 组件只会在离它最近的祖先 connect 组件更新后才会接受到来自 store 的更新。然而，这个实现依赖于每个 `connect()`实例里面覆写了内部 React Context 的一部分（subscription 那部分），用它自身的 Subscription 实例用于嵌套。然后用这个新的 React Context ( \<ReactReduxContext.Provider\> ) 渲染子节点。
>
> 如果用 hooks，没有办法渲染一个 context.Provider，这就代表它不能让 subscriptions 有嵌套的结构。因为这一点，"stale props" 和 "zombie child" 问题可能在『用 hooks 代替 connect』 的应用里重新发生。
>
> 具体来说，"stale props" 会出现在这种场景：
>
> - selector 函数会根据这个组件的 props 计算出数据
> - 父组件会重新 render，并传给这个组件新的 props
> - 但是这个组件会在 props 更新之前就执行 selector（译者注：因为子组件的来自 store 的更新是在 useLayoutEffect/useEffect 中注册的，所以子组件先于父组件注册，redux 触发订阅会先触发子组件的更新方法）
>
> 这种旧的 props 和最新 store state 算出来的结果，很有可能是错误的，甚至会引起报错。
>
> "Zombie child"具体是指在以下场景：
>
> - 多个嵌套的 connect 组件 mounted，子组件比父组件更早的注册到 store 上
> - 一个 action dispatch 了在 store 里删除数据的行为，比如一个 todo list 中的 item
> - 父组件在渲染的时候就会少一个 item 子组件
> - 但是，因为子组件是先被订阅的，它的 subscription 先于父组件。当它计算一个基于 store 和 props 计算的值时，部分数据可能已经不存在了，如果计算逻辑不注意的话就会报错。
>
> `useSelector()`试图这样解决这个问题：它会捕获所有来自 store 更新导致的 selector 计算中的报错，当错误发生时，组件会强制更新，这时 selector 会再次执行。这个需要 selector 是个纯函数并且你没有逻辑依赖 selector 抛出错误。
>
> 如果你更喜欢自己处理，这里有一个可能有用的事项能帮助你在使用 `useSelector()` 时避免这些问题
>
> - 不要在 selector 的计算中依赖 props
> - 如果在：你必须要依赖 props 计算并且 props 将来可能发生变化、依赖的 store 数据可能会被删除，这两种情况下时，你要防备性的写 selector。不要直接像 `state.todos[props.id].name` 这样读取值，而是先读取 `state.todos[props.id]`，验证它是否存在再读取 `todo.name`
>   因为 `connect` 向 context provider 增加了必要的 `Subscription`，它会延迟执行子 subscriptions 直到这个 connected 组件 re-rendered。组件树中如果有 connected 组件在使用 `useSelector` 的组件的上层，也可以避免这个问题，因为父 connect 有和 hooks 组件同样的 store 更新（译者注：父 connect 组件更新后才会更新子 hooks 组件，同时 connect 组件的更新会带动子节点更新，被删除的节点在此次父组件的更新中已经卸载了：因为上文中说 `state.todos[props.id].name` ，说明 hooks 组件是上层通过 ids 遍历出来的。于是后续来自 store 的子 hooks 组件更新不会有被删除的）

以上的解释可能让大家明白了 "Stale Props" 和 "Zombie Children" 问题是如何产生的以及 react-redux 大概是怎么解决的，就是通过子代 connect 的更新被嵌套收集到父级 connect，每次 redux 更新并不是遍历更新所有 connect，而是父级先更新，然后子代由父级更新后才触发更新。但是似乎 hooks 的出现让它并不能完美解决问题了，而且具体这些设计的细节也没有说到。这部分的疑惑和缺失就是我准备再读 react-redux 源码的原因。

## React-Redux 源码解析

React-Redux 版本来自截止 2022.01.27 时的最新版本 v8.0.0-beta.2（有点悲催的是，前几天读源码的时候还是 7 版本，没想到刚读完就升到 8 了，不过主要是从 js 升级到 ts 以及一些小改动）

在讲具体细节之前我想先说一下总体的抽象设计，让大家心中带着设计蓝图去读其中的细节，否则只看细节很难让它们之间串联起来明白它们是如何共同协作完成整个功能的。

React-Redux 的 Provider 和 connect 都提供了自己的贯穿子树的 context，它们的所有的子节点都可以拿到它们，并会将自己的更新方法交给它们。最终形成了**根 <-- 父 <-- 子**这样的收集顺序。根收集的更新方法会由 redux 触发，父收集的更新方法在父更新后再更新，于是保证了父节点被 redux 更新后子节点才更新的顺序。

![react-redux过程抽象图](https://user-images.githubusercontent.com/42726028/151991192-d7ba1abf-c849-42b1-8d7f-da991d40c70d.jpeg)

简单的宏观设计就如上所示，初次看不能理解的很深入，不过没关系，多看几遍源码和源码分析后再回过头看看这里会有新的收获。

### 首先从项目构建入口看起

![image](https://user-images.githubusercontent.com/42726028/151580982-94bb6e23-aa03-4c41-8197-89a42a49ef73.png)

可以看出它的 umd 包是通过 rollup 构建的（`build:umd`、`build:umd:min`），esm 和 commonjs 包是通过 babel 编译输出的（`build:commonjs`、`build:es`）。我们只看`build:es`：`"babel src --extensions \".js,.ts,.tsx\" --out-dir es"`。意思是使用 babel 转换 src 目录下的`.js,.ts,.tsx`文件并输出到 es 目录（这一点和业务项目有些区别，因为 npm 包并不需要打包为一个文件，否则安装的不同 npm 包之间可能会打包进重复依赖，每个文件依然保持 import 引入只是内容编译就可以了，最终在开发者的项目里会把它们构建到一起的）。

下面看一下.babelrc.js 做了什么

![image](https://user-images.githubusercontent.com/42726028/151946191-2fa1bd0c-1b6e-4fed-8183-217d7f1ced53.png)

可以看到 babel 的 presets 中的`@babel/preset-typescript`负责将 ts 编译为 js，`@babel/preset-env`负责将 ECMA 最新语法编译为 es5（只能编译 syntax，api 需要额外插件）。关于 babel 的 plugins，`@babel/transform-modules-commonjs`解决了 babel 重复 helper 的问题，可以按需引入统一的 corejs 库中的 api polyfill，这里是通过 `useESModules` 的配置来决定采用 esm 还是 commonjs 的 helper，但[官方文档](https://babeljs.io/docs/en/babel-plugin-transform-runtime#useesmodules)中在 7.13.0 开始已经废弃这个配置了，可以直接通过`package.json`的`exports`来判断。其他的 plugin 也都是和语法编译相关的，比如私有方法、私有属性、静态属性、jsx、装饰器等语法的编译，以及`@babel/plugin-transform-modules-commonjs`这个将 esm 引入语法编译为 commonjs 的库，由环境变量 NODE_ENV 决定是否使用，它决定了最终输出的是 esm 库还是 commonjs 库。

![image](https://user-images.githubusercontent.com/42726028/151973195-33689fb8-f356-45c8-99cd-bcd1403cf4c3.png)

根据 package.json 的 module 字段（[关于 main、module、browser 字段的优先级](https://github.com/SunshowerC/blog/issues/8)），最终入口是根目录下的 es/index.js，由于它是由 babel 根据源目录输出的，所以源代码入口就是`src/index.ts`。

![image](https://user-images.githubusercontent.com/42726028/151975000-bb4ad66e-facf-4be0-a2ce-a4ffef03b81a.png)

### 从常用的 api 切入

从上图可以看出，入口文件的输出只有`batch`和`exports.ts`文件的全部 export，所以我们去看 `exports.ts`

![image](https://user-images.githubusercontent.com/42726028/151975781-995c5c6e-f626-4b3b-ab85-a29537164eb3.png)

其中的`Provider`、`connect`、`useSelector`、`useDispatch`占据了我们平时使用的大部分场景，所以我们从这 4 个 api 切入。

#### Provider

![image](https://user-images.githubusercontent.com/42726028/151976522-556eec40-dfdf-4182-b465-d13bd223cc06.png)

`Provider`来自`src/components/Provider.tsx`。

它是一个 React 组件，本身并没有任何视图内容，最终展示的是 children，只不过给 children 外面加了一层 [Context Provider](https://reactjs.org/docs/context.html#gatsby-focus-wrapper)，这也是这个 api 为什么叫 Provider 的原因。那具体这个组件想往下面透传什么呢。

```ts
const contextValue = useMemo(() => {
  const subscription = createSubscription(store);
  return {
    store,
    subscription,
    getServerState: serverState ? () => serverState : undefined,
  };
}, [store, serverState]);
```

可以看到透传的是一个由`store`、`subscription`、`getServerState`组成的对象。下面分别讲一下对象的 3 个属性作用。

`store`是 redux 的 store，是开发者通过 store prop 传给 Provider 组件的。

`subscription` 是由 createSubscription 这个对象工厂创建的，它生成了 subscription 对象，它是后续嵌套收集订阅的**关键**。关于 createSubscription 的代码细节后面会说。

`getServerState`是 8.0.0 版本新加的，它用于在 SSR 中，当初始『注水』`hydrate` 时获取服务器端状态快照的，以便保证两端状态一致性。它的控制权完全在开发者，只要把状态快照通过 serverState 这个 prop 给 Provider 组件即可。不了解 SSR、hydrate 相关概念的可以去读一下 Dan Abramov 的一篇[discussions](https://github.com/reactwg/react-18/discussions/37)，虽然它的主题不是专门讲 SSR 的，但是开头介绍了它的相关概念，而且 Dan 的文章一向形象而通俗易懂。

Provider 组件紧接着做的事情是：

```ts
const previousState = useMemo(() => store.getState(), [store]);

useIsomorphicLayoutEffect(() => {
  const { subscription } = contextValue;
  subscription.onStateChange = subscription.notifyNestedSubs;
  subscription.trySubscribe();

  if (previousState !== store.getState()) {
    subscription.notifyNestedSubs();
  }
  return () => {
    subscription.tryUnsubscribe();
    subscription.onStateChange = undefined;
  };
}, [contextValue, previousState]);

const Context = context || ReactReduxContext;

return <Context.Provider value={contextValue}>{children}</Context.Provider>;
```

获取了一次最新 state 并命名为 `previousState`，只要 store 单例不发生变化，它是不会更新的。一般项目中也不太会改变 redux 单例。

`useIsomorphicLayoutEffect` 只是一个 [facade](https://en.wikipedia.org/wiki/Facade_pattern)，从 isomorphic 的命名也可以看出它是和同构相关的。它内部会在 server 环境时使用 useEffect，在浏览器环境时使用 useLayoutEffect

它的代码很简单：

```ts
import { useEffect, useLayoutEffect } from "react";

// React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
// subscription callback always has the selector from the latest render commit
// available, otherwise a store update may happen between render and the effect,
// which may cause missed updates; we also must ensure the store subscription
// is created synchronously, otherwise a store update may occur before the
// subscription is created and an inconsistent state may be observed

// Matches logic in React's `shared/ExecutionEnvironment` file
export const canUseDOM = !!(
  typeof window !== "undefined" &&
  typeof window.document !== "undefined" &&
  typeof window.document.createElement !== "undefined"
);

export const useIsomorphicLayoutEffect = canUseDOM
  ? useLayoutEffect
  : useEffect;
```

但是这样做的原因并不简单：首先，在服务端使用 useLayoutEffect 会抛出警告，为了绕过它于是在服务端转而使用 useEffect。其次，为什么一定要在 useLayoutEffect/useEffect 里面做？因为一个 store 更新可能发生在 render 阶段和副作用阶段之间，如果在 render 时就做，可能会错过更新，必须要确保 store subscription 的回调拥有来自最新更新的 selector。同时还要确保 store subscription 的创建必须是同步的，否则一个 store 更新可能发生在订阅之前（如果订阅是异步的话），这时订阅还没有被创建，从而有了不一致的状态。

如果原因看了不是很明白，结合下面的例子就明白了。

Provider 在 `useIsomorphicLayoutEffect` 里做了这样的事：

```ts
subscription.trySubscribe();

if (previousState !== store.getState()) {
  subscription.notifyNestedSubs();
}
```

首先收集 subscription 的订阅，然后看最新的状态和之前在 render 的状态是否一致，如果不一致则通知更新。如果这一段不放在 useLayoutEffect/useEffect 里，而是放在 render 里，那么现在仅仅订阅了它自己，它的子组件并没有订阅，如果子组件在渲染过程中更新了 redux store，那么子组件们就错过了更新通知。同时 react 的 useLayoutEffect/useEffect 是自下而上调用的，子组件的先调用，父组件的后调用。这里由于是 react-redux 的根节点了，它的 useLayoutEffect/useEffect 会在最后被调用，这时能确保子组件该注册订阅的都注册了，同时也能确保子组件渲染过程中可能发生的更新都已经发生了。所以再最后读取一次 state，比较一下是否要通知它们更新。这就是为什么要选择 useLayoutEffect/useEffect。

接下来我们完整的看一下 Provider 在 `useIsomorphicLayoutEffect` 中做的事情

```ts
useIsomorphicLayoutEffect(() => {
  const { subscription } = contextValue;
  subscription.onStateChange = subscription.notifyNestedSubs;
  subscription.trySubscribe();

  if (previousState !== store.getState()) {
    subscription.notifyNestedSubs();
  }
  return () => {
    subscription.tryUnsubscribe();
    subscription.onStateChange = undefined;
  };
}, [contextValue, previousState]);
```

首先是设置 subscription 的 onStateChange（它初始是个空方法，需要注入实现），它会在触发更新时调用，它这里希望将来调用的是`subscription.notifyNestedSubs`，`subscription.notifyNestedSubs`会触发这个 subscription 收集的所有子订阅。也就是说这里的更新回调和『更新』没有直接关系，而是触发子节点们的更新方法。

然后调用了`subscription.trySubscribe()`，它会将自己的 onStateChange 交给父级 subscription 或者 redux 去订阅，将来由它们触发 onStateChange

最后它会判断之前的 state 和最新的是否一致，如果不一致会调用`subscription.notifyNestedSubs()`，它会触发这个 subscription 收集的所有子订阅从而更新它们。

返回了注销相关的函数，它会注销在父级的订阅，将`subscription.onStateChange`重新置为空方法。这个函数会在组件卸载或 re-render （仅 store 变化时）时被调用（react useEffect 的特性）。

Provider 有很多地方都涉及到了 subscription，subscription 的那些方法只是讲了大概功能，关于 subscription 的细节会在后面 subscription 的部分讲到。

完整的`Provider`源码和注释如下：

```ts
function Provider<A extends Action = AnyAction>({
  store,
  context,
  children,
  serverState,
}: ProviderProps<A>) {
  // 生成了一个用于context透传的对象，包含redux store、subscription实例、SSR时可能用到的函数
  const contextValue = useMemo(() => {
    const subscription = createSubscription(store);
    return {
      store,
      subscription,
      getServerState: serverState ? () => serverState : undefined,
    };
  }, [store, serverState]);

  // 获取一次当前的redux state，因为后续子节点的渲染可能会修改state，所以它叫previousState
  const previousState = useMemo(() => store.getState(), [store]);

  // 在useLayoutEffect或useEffect中
  useIsomorphicLayoutEffect(() => {
    const { subscription } = contextValue;
    // 设置subscription的onStateChange方法
    subscription.onStateChange = subscription.notifyNestedSubs;
    // 将subscription的更新回调订阅给父级，这里会订阅给redux
    subscription.trySubscribe();

    // 判断state经过渲染后是否变化，如果变化则触发所有子订阅更新
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    // 组件卸载时的注销操作
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = undefined;
    };
  }, [contextValue, previousState]);

  const Context = context || ReactReduxContext;

  // 最终Provider组件只是为了将contextValue透传下去，组件UI完全使用children
  return <Context.Provider value={contextValue}>{children}</Context.Provider>;
}
```

总结一下 Provider 其实很简单，Provider 组件只是为了将 contextValue 透传下去，让子组件能够拿到 redux store、subscription 实例、服务器端状态函数。

#### Subscription

这里会讲到 Provider 中出镜率很高的 subscription 部分，它是 react-redux 能够嵌套收集订阅的关键。其实这个部分的标题叫做 `Subscription` 已经不太合适了，在 8.0.0 版本之前，react-redux 确实是通过 Subscription class 实现它的，你可以通过`new Subscription()`使用创建 subscription 实例。但在 8.0.0 之后，已经变成了`createSubscription`函数创建 subscription 对象，内部用闭包替代原先的属性。

用函数替代 class 有一个好处是，不需要关心 this 的指向，函数返回的方法修改的永远是内部的闭包，不会出现 class 方法被赋值给其他变量后出现 this 指向变化的问题，降低了开发时的心智负担。闭包也更加私有化，增加了变量安全。同时在一个支持 hooks 的库里，用函数实现也更符合开发范式。

下面我们先看一下 createSubscription 抽象后的代码，每个的职责都写在注释里了

> 注：下文出现的『订阅回调』具体是指，redux 状态更新后触发的组件的更新方法。组件更新方法被父级订阅收集，是订阅发布模式。

```ts
function createSubscription(store: any, parentSub?: Subscription) {
  // 自己是否被订阅的标志
  let unsubscribe: VoidFunc | undefined;
  // 负责收集订阅的收集器
  let listeners: ListenerCollection = nullListeners;

  // 收集订阅
  function addNestedSub(listener: () => void) {}

  // 通知订阅
  function notifyNestedSubs() {}

  // 自己的订阅回调
  function handleChangeWrapper() {}

  // 判断自己是否被订阅
  function isSubscribed() {}

  // 让自己被父级订阅
  function trySubscribe() {}

  // 从父级注销自己的订阅
  function tryUnsubscribe() {}

  const subscription: Subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe,
    tryUnsubscribe,
    getListeners: () => listeners,
  };

  return subscription;
}
```

`createSubscription`函数是一个对象工厂，它定义了一些变量和方法，然后返回一个拥有这些方法的对象`subscription`

首先看一下 `handleChangeWrapper`，通过名字可以看出它只是一个外壳

```ts
function handleChangeWrapper() {
  if (subscription.onStateChange) {
    subscription.onStateChange();
  }
}
```

其内部实际调用了`onStateChange`方法。究其原因是因为在订阅回调被父级收集时，可能自己的回调还没有确定，所以定义了一个外壳用于被收集，内部的回调方法在确定时会被重置，但外壳的引用不变，所以将来依然可以触发回调。这也是为什么在`Provider.ts`的源码里，在收集订阅之前先做一下`subscription.onStateChange = subscription.notifyNestedSubs`的原因。

然后看 `trySubscribe`

```ts
function trySubscribe() {
  if (!unsubscribe) {
    unsubscribe = parentSub
      ? parentSub.addNestedSub(handleChangeWrapper)
      : store.subscribe(handleChangeWrapper);

    listeners = createListenerCollection();
  }
}
```

它的作用是让父级的 subscription 收集自己的订阅回调。首先它会判断如果`unsubscribe`标志了它已经被订阅了，那么不做任何事。其次它会判断当时创建`subscription`时的第二个参数`parentSub`是否为空，如果有`parentSub`则代表它上层有父级`subscription`，那么它会调用父级的`addNestedSub`方法，将自己的订阅回调注册给它；否则则认为自己在顶层，所以注册给 redux store。

由此引申到需要看看`addNestedSub`方法是什么

```ts
function addNestedSub(listener: () => void) {
  trySubscribe();
  return listeners.subscribe(listener);
}
```

`addNestedSub`非常巧妙的运用了递归，它里面又调用了`trySubscribe`。于是它们就会达到这样的目的，当最底层`subscription`发起`trySubscribe`想被父级收集订阅时，它会首先触发父级的`trySubscribe`并继续递归直到根`subscription`，如果我们把这样的层级结构想象成树的话（其实 subscription.trySubscribe 也确实发生在组件树中），那么就相当于从根节点到叶子节点依次会被父级收集订阅。因为这是由叶子节点先发起的，这时除了叶子节点，其他节点的订阅回调还没有被设置，所以才设计了`handleChangeWrapper`这个回调外壳，注册的只是这个回调外壳，在将来非叶子节点设置好回调后，能被外壳触发。

在『递』过程结束后，从根节点开始到这个叶子节点的订阅回调`handleChangeWrapper`都正在被父级收集了，『归』的过程回溯做它的本职工作`return listeners.subscribe(listener)`，将子`subscription`的订阅回调收集到收集器`listeners`中（将来更新发生时会触发相关的`handleChangeWrapper`，而它会间接的调用收集到所有的 listener）。

所以每个`subscription`的`addNestedSub`都做了两件事：1. 让自己的订阅回调先被父级收集；2. 收集子`subscription`的订阅回调。

结合`addNestedSub`的解释再回过头来看`trySubscribe`，它想让自己的订阅回调被父级收集，于是当它被传入父级`subscription`时，就会调用它的`addNestedSub`，这会导致从根`subscription`开始每一层`subscription`都被父级收集了回调，于是每个`subscription`都嵌套收集了它们子`subscription`，从而父级更新后子级才更新成为了可能。同时，因为`unsubscribe`这个锁的存在，如果某个父级`subscription`的`trySubscribe`被调用了，并不会重复的触发这个『嵌套注册』。

上面我们分析了『嵌套注册』时发生了什么，下面我们看看注册的实质性操作`listeners.subscribe`干了什么，注册的数据结构又是如何设计的。

```ts
function createListenerCollection() {
  const batch = getBatch();
  // 对listener的收集，listener是一个双向链表
  let first: Listener | null = null;
  let last: Listener | null = null;

  return {
    clear() {
      first = null;
      last = null;
    },

    // 触发链表所有节点的回调
    notify() {
      batch(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },

    // 以数组的形式返回所有节点
    get() {
      let listeners: Listener[] = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },

    // 向链表末尾添加节点，并返回一个删除该节点的undo函数
    subscribe(callback: () => void) {
      let isSubscribed = true;

      let listener: Listener = (last = {
        callback,
        next: null,
        prev: last,
      });

      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }

      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;

        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    },
  };
}
```

`listeners`对象是由`createListenerCollection`创建的。`listeners`方法不多且逻辑易懂，是由`clear`、`notify`、`get`、`subscribe`组成的。

listeners 负责收集 listener（也就是订阅回调） ，listeners 内部将 listener 维护成了一个双向链表，头结点是`first`，尾节点是`last`。

`clear`方法如下：

```ts
clear() {
  first = null
  last = null
}
```

用于清空收集的链表

`notify`方法如下：

```ts
notify() {
  batch(() => {
    let listener = first
    while (listener) {
      listener.callback()
      listener = listener.next
    }
  })
}
```

用于遍历调用链表节点，`batch`这里可以简单的理解为调用入参的函数，更多细节后面再说。

`get`方法如下：

```ts
get() {
  let listeners: Listener[] = []
  let listener = first
  while (listener) {
    listeners.push(listener)
    listener = listener.next
  }
  return listeners
}
```

用于将链表节点转为数组的形式并返回

`subscribe`方法如下：

```ts
subscribe(callback: () => void) {
  let isSubscribed = true

  // 创建一个链表节点
  let listener: Listener = (last = {
    callback,
    next: null,
    prev: last,
  })

  // 如果链表已经有了节点
  if (listener.prev) {
    listener.prev.next = listener
  } else {
    // 如果链表还没有节点，它则是首节点
    first = listener
  }

  // unsubscribe就是个双向链表的删除指定节点操作
  return function unsubscribe() {
    // 阻止无意义执行
    if (!isSubscribed || first === null) return
    isSubscribed = false

    // 如果添加的这个节点已经有了后续节点
    if (listener.next) {
      // next的prev应该为该节点的prev
      listener.next.prev = listener.prev
    } else {
      // 没有则说明该节点是最后一个，将prev节点作为last节点
      last = listener.prev
    }
    // 如果有前节点prev
    if (listener.prev) {
      // prev的next应该为该节点的next
      listener.prev.next = listener.next
    } else {
      // 否则说明该节点是第一个，把它的next给first
      first = listener.next
    }
  }
}
```

用于向 listeners 链表添加一个订阅以及返回一个注销订阅的函数，涉及链表的增删操作，具体看注释即可。

所以每个`subscription`收集订阅实则是维护了一个双向链表。

`subscription`最后需要说的的部分只有`notifyNestedSubs`和`tryUnsubscribe`了

```ts
notifyNestedSubs() {
  this.listeners.notify()
}

tryUnsubscribe() {
  if (this.unsubscribe) {
    this.unsubscribe()
    this.unsubscribe = null
    this.listeners.clear()
    this.listeners = nullListeners
  }
}
```

`notifyNestedSubs`调用了`listeners.notify`，根据上面有关 listeners 的分析，这里会遍历调用所有的订阅

`tryUnsubscribe`则是进行注销相关的操作，`this.unsubscribe`在`trySubscribe`方法的执行中被注入值了，它是`addNestedSub`或者`redux subscribe`函数的返回值，是取消订阅的 undo 操作。在`this.unsubscribe()`之下的分别是清除`unsubscribe`、清除`listeners`操作。

至此`subscription`就分析完了，它主要用于在嵌套调用时，可以嵌套收集订阅，以此做到父级更新后才执行子节点的订阅回调从而在父级更新之后更新。不太清楚 react-redux 的人可能会疑惑，不是只有`Provider`组件使用了`subscription`吗，哪里来的嵌套调用？哪里来的收集子订阅？不要着急，后续讲到`connect`高阶函数，它里面也用到了`subscription`，就是这里嵌套使用的。

#### connect

8.0.0 开始由`connect.tsx`代替`connectAdvanced.js`，本质上都是多层高阶函数，但重构后的`connect.tsx`结构显得更加清晰直观。

我们都知道在使用 connect 的时候都是：`connect(mapStateToProps, mapDispatchToProps, mergeProps, connectOptions)(Component)`，因此它入口应该是接收`mapStateToProps`、`mapDispatchToProps`等参数，返回一个接收`Component`参数的高阶函数，这个函数最终返回`JSX.Element`。

如果简单看 connect 的结构就如下所示：

```ts
function connect(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  {
    pure,
    areStatesEqual,
    areOwnPropsEqual,
    areStatePropsEqual,
    areMergedPropsEqual,
    forwardRef,
    context,
  }
) {
  const wrapWithConnect = (WrappedComponent) => {
    return <WrappedComponent />;
  };
  return wrapWithConnect;
}
```

如果把 connect 做的事情分解的话，我认为有这几块：向父级订阅自己的更新、从 redux store select 数据、判断是否需要更新等其他细节

**connect 的 selector**

```ts
const initMapStateToProps = match(
  mapStateToProps,
  // @ts-ignore
  defaultMapStateToPropsFactories,
  "mapStateToProps"
)!;
const initMapDispatchToProps = match(
  mapDispatchToProps,
  // @ts-ignore
  defaultMapDispatchToPropsFactories,
  "mapDispatchToProps"
)!;
const initMergeProps = match(
  mergeProps,
  // @ts-ignore
  defaultMergePropsFactories,
  "mergeProps"
)!;

const selectorFactoryOptions: SelectorFactoryOptions<any, any, any, any> = {
  pure,
  shouldHandleStateChanges,
  displayName,
  wrappedComponentName,
  WrappedComponent,
  initMapStateToProps,
  initMapDispatchToProps,
  // @ts-ignore
  initMergeProps,
  areStatesEqual,
  areStatePropsEqual,
  areOwnPropsEqual,
  areMergedPropsEqual,
};

const childPropsSelector = useMemo(() => {
  // The child props selector needs the store reference as an input.
  // Re-create this selector whenever the store changes.
  return defaultSelectorFactory(store.dispatch, selectorFactoryOptions);
}, [store]);

const actualChildPropsSelector = childPropsSelector(
  store.getState(),
  wrapperProps
);
```

`match`函数是首个需要被分析的

```ts
function match<T>(
  arg: unknown,
  factories: ((value: unknown) => T)[],
  name: string
): T {
  for (let i = factories.length - 1; i >= 0; i--) {
    const result = factories[i](arg);
    if (result) return result;
  }

  return ((dispatch: Dispatch, options: { wrappedComponentName: string }) => {
    throw new Error(
      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${
        options.wrappedComponentName
      }.`
    );
  }) as any;
}
```

`factories`作为一个工厂数组，会被传入`arg`参数遍历调用，每个工厂都会检测处理`arg`，而这里的`arg`就是我们开发中写的`mapStateToProps`、`mapDispatchToProps`、`mergeProps`，直到`factories[i](arg)`有值才会 return，如果一直都不是 truly 值，则会报错。`factories`就像**责任链模式**一样，属于自己的工厂职责就会处理并返回。

`factories`在`initMapStateToProps`、`initMapDispatchToProps`、`initMergeProps`中是不同的，分别是`defaultMapStateToPropsFactories`、`defaultMapDispatchToPropsFactories`、`defaultMergePropsFactories`，我们来看看它们是什么。

```ts
// defaultMapStateToPropsFactories

function whenMapStateToPropsIsFunction(mapStateToProps?: MapToProps) {
  return typeof mapStateToProps === "function"
    ? wrapMapToPropsFunc(mapStateToProps, "mapStateToProps")
    : undefined;
}

function whenMapStateToPropsIsMissing(mapStateToProps?: MapToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : undefined;
}

const defaultMapStateToPropsFactories = [
  whenMapStateToPropsIsFunction,
  whenMapStateToPropsIsMissing,
];
```

遍历`defaultMapStateToPropsFactories`是调用了`whenMapStateToPropsIsFunction`、`whenMapStateToPropsIsMissing`这两个工厂，由名字可以看出第一个是当`mapStateToProps`是函数时处理，第二个是省略`mapStateToProps`时处理。

里面的`wrapMapToPropsFunc`函数（即`whenMapStateToPropsIsFunction`）将 `mapToProps` 包装在一个代理函数中，它做了几件事：

1. 检测被调用的 mapToProps 函数是否依赖于 props，其中 selectorFactory 使用它来决定它是否应该在 props 更改时重新调用。
2. 在第一次调用时，如果`mapToProps`返回另一个函数，则处理 `mapToProps`，并处理把新函数作为后续调用的真正 mapToProps。
3. 在第一次调用时，验证结果是否为一个平层的对象，以警告开发人员的 mapToProps 函数未返回有效结果。

`wrapMapToPropsConstant`函数（即`whenMapStateToPropsIsMissing`）在缺省时将来会返回空对象（并不是立即返回，返回的是高阶函数），有值时期望那个值是函数，将`dispatch`传入函数，最后返回这个函数的返回值（同样不是立即返回）

另外两个工厂组`defaultMapDispatchToPropsFactories`、`defaultMergePropsFactories`，职责和`defaultMapStateToPropsFactories`一样，本质上就是负责处理不同 case 时的`arg`

```ts
const defaultMapDispatchToPropsFactories = [
  whenMapDispatchToPropsIsFunction,
  whenMapDispatchToPropsIsMissing,
  whenMapDispatchToPropsIsObject,
];

const defaultMergePropsFactories = [
  whenMergePropsIsFunction,
  whenMergePropsIsOmitted,
];
```

相信大家通过名字也能大概猜出它们负责什么，就不一一细说了。

经过`match`处理后，返回了`initMapStateToProps`、`initMapDispatchToProps`、`initMergeProps`这 3 个高阶函数
，最终这些函数的目的是返回 select 的值

```ts
const selectorFactoryOptions: SelectorFactoryOptions<any, any, any, any> = {
  pure,
  shouldHandleStateChanges,
  displayName,
  wrappedComponentName,
  WrappedComponent,
  initMapStateToProps,
  initMapDispatchToProps,
  // @ts-ignore
  initMergeProps,
  areStatesEqual,
  areStatePropsEqual,
  areOwnPropsEqual,
  areMergedPropsEqual,
};
```

它们以及其他属性组成名为`selectorFactoryOptions`的对象

最终交给`defaultSelectorFactory`使用

```ts
const childPropsSelector = useMemo(() => {
  // The child props selector needs the store reference as an input.
  // Re-create this selector whenever the store changes.
  return defaultSelectorFactory(store.dispatch, selectorFactoryOptions);
}, [store]);
```

而`childPropsSelector`就是最终返回真正需要值的函数（它真的是高阶函数的终点了~）

所以最后只需要看`defaultSelectorFactory`函数做了什么，它实际叫`finalPropsSelectorFactory`

```ts
export default function finalPropsSelectorFactory<
  TStateProps,
  TOwnProps,
  TDispatchProps,
  TMergedProps,
  State = DefaultRootState
>(
  dispatch: Dispatch<Action>,
  {
    initMapStateToProps,
    initMapDispatchToProps,
    initMergeProps,
    ...options
  }: SelectorFactoryOptions<
    TStateProps,
    TOwnProps,
    TDispatchProps,
    TMergedProps,
    State
  >
) {
  const mapStateToProps = initMapStateToProps(dispatch, options);
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  const mergeProps = initMergeProps(dispatch, options);

  if (process.env.NODE_ENV !== "production") {
    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);
  }

  return pureFinalPropsSelectorFactory<
    TStateProps,
    TOwnProps,
    TDispatchProps,
    TMergedProps,
    State
    // @ts-ignore
  >(mapStateToProps!, mapDispatchToProps, mergeProps, dispatch, options);
}
```

`mapStateToProps`、`mapDispatchToProps`、`mergeProps`是会返回各自最终值的函数。更多应该关注的重点是`pureFinalPropsSelectorFactory`函数

```ts
export function pureFinalPropsSelectorFactory<
  TStateProps,
  TOwnProps,
  TDispatchProps,
  TMergedProps,
  State = DefaultRootState
>(
  mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State> & {
    dependsOnOwnProps: boolean;
  },
  mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps> & {
    dependsOnOwnProps: boolean;
  },
  mergeProps: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,
  dispatch: Dispatch,
  {
    areStatesEqual,
    areOwnPropsEqual,
    areStatePropsEqual,
  }: PureSelectorFactoryComparisonOptions<TOwnProps, State>
) {
  let hasRunAtLeastOnce = false;
  let state: State;
  let ownProps: TOwnProps;
  let stateProps: TStateProps;
  let dispatchProps: TDispatchProps;
  let mergedProps: TMergedProps;

  function handleFirstCall(firstState: State, firstOwnProps: TOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    // @ts-ignore
    stateProps = mapStateToProps!(state, ownProps);
    // @ts-ignore
    dispatchProps = mapDispatchToProps!(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    // @ts-ignore
    stateProps = mapStateToProps!(state, ownProps);

    if (mapDispatchToProps!.dependsOnOwnProps)
      // @ts-ignore
      dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps!.dependsOnOwnProps)
      // @ts-ignore
      stateProps = mapStateToProps!(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps)
      // @ts-ignore
      dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps);
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    // @ts-ignore
    stateProps = nextStateProps;

    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

    return mergedProps;
  }

  function handleSubsequentCalls(nextState: State, nextOwnProps: TOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    const stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;

    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(
    nextState: State,
    nextOwnProps: TOwnProps
  ) {
    return hasRunAtLeastOnce
      ? handleSubsequentCalls(nextState, nextOwnProps)
      : handleFirstCall(nextState, nextOwnProps);
  };
}
```

它的闭包`hasRunAtLeastOnce`用以区分是否首次调用，首次和后续是不同的函数，如果是首次调用则是使用`handleSubsequentCalls`函数，它里面产生`stateProps`、产生`dispatchProps`，然后将它们放入`mergeProps`计算出最终的 props，同时把`hasRunAtLeastOnce`设置为`true`，表示已经不是第一次执行了。

后续调用都走`handleSubsequentCalls`，它的主要目的是如果 state 和 props 都没有变化则使用缓存数据（state、props 是否变化的判断方法是外部传进来的，组件当然能知道自己有没有变化），如果 state、props 都有变化或者只是其中一个有变化，再分别调用各自的函数（里面主要是根据静态属性`dependsOnOwnProps`判断是否要重新执行）得到新值。

于是`childPropsSelector`函数就是返回的`pureFinalPropsSelector`函数，内部访问了闭包，闭包保存了持久值，从而在组件多次执行的情况下，可以决定是否需要使用缓存来优化性能。

selector 相关的分析完了。

> 总的来说，如果想实现一个最简单的`selector`，只需要
>
> ```js
> const selector = (state, ownProps) => {
>   const stateProps = mapStateToProps(reduxState);
>   const dispatchProps = mapDispatchToProps(reduxDispatch);
>   const actualChildProps = mergeProps(stateProps, dispatchProps, ownProps);
>   return actualChildProps;
> };
> ```
>
> 那为什么 react-redux 会写的如此复杂呢。就是为了`connect`组件在多次执行时能利用细粒度缓存的 `mergedProps` 值提升性能，React 只能做到在`wrapperProps`不变时使用 memo，但难以做更细粒度的区分，比如知道 selector 是否依赖 props，从而就算 props 变化了也不需要更新。要实现这一点需要大量嵌套的高阶函数储存持久化的闭包中间值，才能在组件多次执行时不丢失状态从而判断更新。

下面我们准备讲点别的了，如果你头有点晕，你只要记住看到了`childPropsSelector`就是返回 selector 后的值就好了。

**connect 更新的注册订阅**
