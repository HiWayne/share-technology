# 21.体系化的前端性能优化详解（未完待续……）

性能优化这个词我们经常会在前端的工作或面试中遇到，这个东西说难好像也并不怎么难，毕竟谁都能说上几点。但是如果你想在工作上遇到各种场景的性能瓶颈时都有直击本质的性能方案，或者在面试时让面试官眼前一亮，那就不能只拘泥于『想到哪说到哪』，而要有一套体系化的、各个角度的知识图谱。这篇文章也算对我个人的前端知识的一次归纳总结，因为『性能优化』不仅仅是『优化』，什么意思呢？优化之前，首先要知道为什么要这样优化，这就需要你对上到框架、js，下到浏览器、网络等等的原理都有不错的了解。所以性能优化真的涵盖了太多前端知识。

首先我们来谈一谈前端性能的本质，前端的输出物是一个网络应用，应用的性能好坏是它的运行效率决定的，前面再加上网络那就是再和网络效率有关。所以前端性能的本质就是网络性能和运行性能。所以前端性能优化体系中的两大分类我认为就是：网络、运行。

# 网络层面

如果我们把网络比做一根水管，前端应用是对面手上的一杯水，你现在想更快接完对面的水，无非就两点：1. 让水管流量变大；2. 让对面杯子里的水变少。水管流量也就是网络带宽，杯子水变少就是比如缓存、压缩、代码分割等等手段。

先说网络，网络不仅由用户的运营商决定，也可以通过网络协议优化其效率。

计算机网络理论上是 OSI 七层模型，实际可以看成五层（或四层模型），分别是物理层、数据链路层、网络层、传输层、应用层，每一层封装解析自己的协议，负责各自的职责，将上层数据交给上层处理。我们主要关注应用层和传输层。

## TCP 协议

我们都知道 tcp 传输前要先建立连接，但实际上网络传输是不需要建连的，网络在设计之初的特点就是突发性、随时发送，所以摈弃了电话网那样的设计。tcp 所谓的连接，其实只是两台设备之间保存彼此通信的一些状态，并不是真正意义上的连接。tcp 需要通过五元组区分是否是同一个连接，有一个元祖是协议，剩下四个是，`src_ip、src_port、dst_ip、dst_port`。另外 tcp 报文段的首部有四个重要的东西，`Sequence Number`是包的序号(seq)，表示这个 packet 的数据部分的第一位应该在整个 data stream 中所在的位置，用来解决网络包乱序问题。`Acknowledgement Number`(ack)表示的是这次收到的数据长度 + 这次的 seq，也是对方（接收方）的下一次 sequence number，用于确认收到，用来解决不丢包的问题。`Window`又叫 Advertised-Window，是滑动窗口，用于解决流控的。`TCP Flag`是包的类型，主要是用于操控 TCP 的状态机。

理一下 tcp 通信的流程，这样才能知道这些环节中可以做什么优化。

### tcp 三次『握手』

初始 seq 序列号（`ISN`）32 位，由虚拟时钟以 4 微秒的频率不断+1 生成，超过 2^32 又回到 0，循环一次需要 4.55 小时。之所以每次建连不固定从 0 开始，是为了避免断线重新建连后，新包和延迟到达的旧包 seq 冲突的问题。4.55 小时已超出 Maximum Segment Lifetime(`MSL`)，旧包已经不存在了。

1. 客户端发出 SYN（flags: SYN）包，假设初始 seq 是 x，所以 seq = x。客户端 tcp 进入 `SYN_SEND` 状态。
2. 服务端 tcp 初始是 `LISTEN` 状态，收到后发送 ACK 包（flags: ACK, SYN），假设初始 seq 是 y，seq = y，ack = x + 1 ，这是因为 flags 有 SYN，占用 1 个长度，所以接下来客户端应该从 x + 1 开始。服务端进入 `SYN_RECEIVED` 状态。
3. 客户端收到后发送 ACK 包，seq = x + 1，ack = y + 1。然后继续发送实际内容的 PSH 包（假设数据长度是 100），seq = x + 1，ack = y + 1。实际内容的 seq、ack 之所以和 ack 包没有变化是因为 Flag 是 ACK 仅用作确认，本身不占用长度。客户端进入 `ESTABLISHED` 状态。
4. 服务端收到后发送 ACK 包，seq = y + 1，ack = x + 101。服务端进入 `ESTABLISHED` 状态。

seq、ack 的计算可以对照这个抓包图（图片来自网络，其中的序列号是相对序号）

![tcp发送过程](https://segmentfault.com/img/remote/1460000016375114/view)

### SYN 超时与攻击

服务端在三次握手时，收到 SYN 包、回了 SYN-ACK 后，tcp 处于半连接的中间状态，操作系统内核会将连接暂时放进 SYN 队列。如果服务端没有收到来自 client 的 ACK，会超时重试，默认重试 5 次，从 1s 开始翻倍，1s、2s、4s……知道第 5 次也超时一共需要 63s，这时 tcp 会断掉这个连接。有些攻击者会利用这个特性，大量对服务端发送 SYN 包然后断开，服务端要等 63s 才将连接从 SYN 队列清除，从而导致服务端 tcp 的 SYN 队列占满，无法再继续提供服务。正常的大并发情况下也可能出现这种情况。这时我们可以在 linux 下设置以下参数：

1. `tcp_syncookies`，它可以在 SYN 队列满了之后将四元组信息、每 64s 递增一次的时间戳、MSS 选项值生成一个特别的 Sequence Number(也叫 cookie)，将这个 cookie 作为 seq 发送给 client 则可以直接建连。tcp_syncookies 通过这种巧妙的方式不需要在本地就保存了 SYN 里的部分信息。细心的观众会发现，tcp_syncookies 似乎只需要两次握手就可以建连了，为什么不把它纳入 tcp 标准呢？因为它也是有缺点的，1. MSS 的编码只有 3 位，因此最多只能使用 8 种 MSS 值。2. 服务端必须拒绝客户端 SYN 报文中的其他只在 SYN 和 SYN+ ACK 中协商的选项，原因是服务端没有地方可以保存这些选项，比如 Wscale 和 SACK。3. 增加了密码学运算。所以在因为正常并发大而出现 SYN 队列满的情况时，不要使用这种方式，它只是一个阉割版的 tcp。

2. `tcp_synack_retries`，用它减少 SYN-ACK 超时的重试次数，也就减少了 SYN 队列的清理时间。

3. `tcp_max_syn_backlog`，增加最大 SYN 连接数，也就是增大 SYN 队列。

4. `tcp_abort_on_overflow`，SYN 队列满就拒绝连接。

### tcp 四次『挥手』

假设是客户端先断开连接，seq 接着上次的握手。

关闭前两端的 tcp 状态都是 `ESTABLISHED`。

1. 客户端发出 FIN 包（flags: FIN）表示可以关闭，seq = x + 101, ack = y + 1。客户端变为 `FIN-WAIT-1` 状态。
2. 服务端收到这个 FIN，返回一个 ACK，seq = y + 1，ack = x + 102。服务端变为 `CLOSE-WAIT` 状态。客户端收到这个 ACK 后变为 `FIN-WAIT-2` 状态。
3. 服务端可能有一些工作未做完，做完后也发送 FIN 包决定关闭，seq = y + 1，ack = x + 102。服务端变为 `LAST-ACK` 状态。
4. 客户端收到 FIN 后返回确认 ACK，seq = x + 102，ack = y + 2。客户端变为 `TIME-WAIT` 状态
5. 服务端收到客户端 ACK 后直接关闭连接，变为 `CLOSED` 状态。客户端等待 2\*MSL 时间后没有再次收到服务端的 FIN，则关闭连接，变为 `CLOSED` 状态。

为何需要长时间的 `TIME-WAIT`？1. 可以避免复用该四元组的新连接接收到延迟的旧包 2. 可以确保服务端已经关闭

为何 `TIME-WAIT` 的时间是 2\*MSL（最大 segment 存活时间，[RFC793](https://www.rfc-editor.org/rfc/rfc793) 定义了 MSL 为 2 分钟，Linux 设置成了 30s）？因为服务端在发送 FIN 后，如果等待 ACK 超时了会重发，FIN 最长存活 MSL 时间，重发一定发生在这之前，重发的 FIN 也是最长存活 MSL 时间。所以 2 倍的 MSL 时间后，客户端依然没有收到服务端的重发，说明服务端已经收到 ACK 关闭了，所以客户端就可以关闭了。

### TIME-WAIT 数量太多如何优化

我们知道在 linux 里默认会等待 1 分钟才关闭连接，这时端口一直是被占用的状态。如果在大并发的短连接下，可能会出现 `TIME-WAIT` 数量过多导致端口被占满、cpu 占用过大的情况。

**前两个配置强烈建议不要用**

1. `tcp_tw_reuse`，必须在客户端和服务端都开启 timestamp 才可使用，仅在客户端生效。开启后不用等待 TIME-WAIT，仅需 1s，新连接可以直接复用这个socket。为什么需要开启 timestamp？因为旧连接的包可能兜兜转转终于到达了服务端，而复用该 socket 的新连接五元组和旧包是一样的，只要时间戳早于新包的肯定是旧连接的包，可以避免无用的旧包被误接受。

2. `tcp_tw_recycle`，tcp_tw_recycle 处理更激进，它会快速回收 TIME_WAIT 状态的 socket 。只有当 tcp_timestamps 和 tcp_tw_recycle 都开启时，才会快速回收。当客户端通过 NAT 环境访服务器端时，服务器端主动关闭后会产生了 TIME_WAIT 状态，如果服务器端同时开启了 tcp_timestamps 和 tcp_tw_recycle 选项时，那么在 60 秒内来自同一源 IP 主机的 TCP 分段的时间戳必须递增，否则会丢弃。Linux 从 4.12 内核版本开始移除了 tcp_tw_recycle 配置。

3. `tcp_max_tw_buckets`，控制并发的 TIME-WAIT 的数量，默认值是 180000，如果超过，系统会销毁并记录 log

4. `ip_local_port_range`，增加客户端端口范围

5. 如果可能的话，增加服务端的服务端口

6. 如果可能的话，增加客户端或服务端的 ip

## http 协议

### http 缓存

如果一份网络资源不需要请求直接从本地缓存拿到，那自然是最快的。http 协议里面定义了缓存机制，其中又分为本地缓存（大家也称它为强缓存）和需要验证的缓存（大家也称它为协商缓存），有一点要注意的是，强缓存和协商缓存似乎并不是一个官方专用名词，更像是一种中文社区的意译。

#### 本地缓存（强缓存）

在 http1.0 是用`expires`响应头表示返回值的过期时间，浏览器在这个时间之内可以不重新请求直接使用缓存。在 http1.1 之后，改为了`Cache-Control`响应头，从此可以满足更多的缓存要求，里面的`max-age`表示资源在请求 N 秒后过期。注意`max-age`不是浏览器收到响应后经过的时间，它是在源服务器上生成响应后经过的时间，和浏览器时间无关。因此，如果网络上的其他缓存服务器将响应存储 100 秒(使用响应报头字段 Age 表示)，浏览器缓存将从其过期时间中扣除 100 秒。当缓存过期后（我们忽略 stale-while-revalidate、max-stale 等的影响），浏览器会发起条件请求验证资源是否更新（也称协商缓存）。

#### 条件请求（协商缓存）

请求头会有`If-Modified-Since`和`If-None-Match`字段，它们分别是上次请求响应头里的`Last-Modified`和`etag`。`Last-Modified`表示资源最后被修改的时间，单位秒。`etag`是特定版本资源的标识（比如对内容 hash 就可以生成一个 etag）。服务器当`If-None-Match`或者`If-Modified-Since`没有变化时会返回 304 状态码的响应，浏览器会认为资源没有更新从而复用本地缓存。由于`Last-Modified`记录的修改时间是秒为单位，如果修改频率发生在 1 秒内就不能准确判断是否更新了，所以`etag`的判断优先级要高于`Last-Modified`。

`Cache-Control`中如果设置`no-cache`会强制不使用强缓存，直接走协商缓存，即 max-age=0。如果设置`no-store`会不使用任何缓存。

浏览器对请求的缓存策略简单来说就是这样，我们可以看出缓存是由响应头和请求头决定的，开发过程中一般已经由网关和浏览器帮我们自动设置好了，如果你有特定需求，可以定制化使用更多`Cache-Control`功能。

#### 完整的 Cache-Control 功能

`Cache-Control`还有更多更细致的缓存控制能力，完整的响应头和请求头含义看下表。

响应头
|名称|含义|
|----|----|
|max-age|max-age 表示资源在请求 N 秒后过期。注意 max-age 不是浏览器收到响应后经过的时间，它是在源服务器上生成响应后经过的时间，和浏览器时间无关|
|s-maxage|响应头特有，作用和 max-age 类似，但是只会被资源共享服务器（如 cdn）使用，如果它存在时将会忽略 max-age|
|no-cache|表示请求可以被缓存，但每次都需要去服务器验证内容是否更新|
|no-store|请求不会以任何形式缓存|
|no-transform|禁止中介服务器转换内容（比如经过某些服务器时会降低画质以减少图片大小，但内容提供者不希望这样）|
|must-revalidate|响应头特有，请求可以被缓存也可以使用强缓存，但缓存过期后必须重新验证更新（因为浏览器允许断线情况下使用过期的缓存），要么重新验证成功，要么返回 504|
|proxy-revalidate|响应头特有，和 must-revalidate 相似，但只能在资源共享服务器（比如 cdn）使用|
|must-understand|响应头特有，只在基于状态码理解缓存需求时才缓存，和 no-store 一起使用可以作为兜底|
|private|响应头特有，只能缓存在私有缓存中，比如浏览器缓存，不会缓存在资源共享服务器（比如 cdn）中|
|public|响应头特有，和 private 相反，需要特定身份的请求不能使用 public，它可能在任何地方被缓存然后被其他用户拿到|
|immutable|响应头特有，缓存内容在有效期内是不会改变的，有效期内不需要有重新验证的协商请求。现代前端应用一般都是名称带 hash 的资源，内容更新 hash 变化后其实已经是另一个请求了，所以请求不变内容也是不变的|
|stale-while-revalidate|响应头特有，当缓存过期后，在 stale-while-revalidate 指定秒数内，后台会重新验证缓存，这段时间内依然可以正常使用本地缓存|
|stale-if-error|当缓存过期后，在 stale-if-error 指定秒数内，请求发生 500, 502, 503, 504 错误时（不管是服务器产生的还是本地产生的）可以使用本地缓存|

请求头（仅列举响应头没有的）
|max-stale|缓存过期不超过 max-stale 秒时依然可用|
|min-fresh|要求缓存服务返回 min-fresh 秒时间内的新鲜缓存数据，否则就不使用本地缓存|
|only-if-cached|浏览器要求仅在缓存服务器缓存了目标资源的情况下才返回|
